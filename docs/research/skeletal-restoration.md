# Восстановление полного цифрового скелета по полученным координатам
Результатом работы MediaPipe является набор точек в трёхмерном пространстве, которые можно исопльзовать для построения цифрового скелета. Однако данных с одной камеры может быть недостаточно: конечность находится вне зоны видимости, неточность определения глубины. Для решения этих проблем можно записывать пациента с нескольких ракурсов и комбинировать полученные результаты, что должно помочь в вычислениях.
## Выходные данные MediaPipe
MediaPipe возвращает координаты точек в особом формате:
```
NormalizedLandmark {
  x: float,
  y: float,
  z: float,
  visibility?: float,
  presence?: float
}
```
Здесь x, y, z - трехмерные координаты точки в нормализованном виде(значение от 0 до 1). Началом координат считается точка между бедёр человека. Поля visibility и presence выставляются в зависимости от используемой модели, но и то, и другое можно использовать для оценки точности определения точки - при усреднении можно использовать в качестве веса данного значения. Кроме того, также имеется временная метка, которую можно исопльзовать для синхронизации потоков данных
## Общий базис
Поскольку камеры снимают с разных точек, данные от разных камер имеют разные базисы, и мы не можем вычислять итоговые координаты напрямую. Требуется переход к общему базису.
### Построение матрицы перехода
#### Классическое определение 
В классической линейной алгебре переход от одного базиса к другому происходит с помощью домножения на матрицу перехода: $$v_a=Pv_b$$
Здесь $v_a$ и $v_b$ - радиус-векторы одной и той же точки в базисах $a$ и $b$ соответственно, а $P$ - матрица перехода. Для нахождения достаточно знать координаты 3 линейно-независимых точек в обоих базисах.
Пусть есть трехмерные точки $A$, $B$ и $C$, и нам известны их координаты в базисах $e$ и $f$. Записав радиус-вектора данных точек как столбцы матриц получаем по определению:
$$M_e=\begin{pmatrix}x_{A_e}&x_{B_e}&x_{C_e}\\y_{A_e}&y_{B_e}&y_{C_e}\\z_{A_e}&z_{B_e}&z_{C_e}\end{pmatrix}=PM_f=P\times\begin{pmatrix}x_{A_f}&x_{B_f}&x_{C_f}\\y_{A_f}&y_{B_f}&y_{C_f}\\z_{A_f}&z_{B_f}&z_{C_f}\end{pmatrix}$$
Домножим обе части на сопряженное к $M_f$, выражаем $P$:
$$PM_fM_f^{-1}=P=M_eM_f^{-1}$$
#### Альтернативный подход
Однако данный подход требует, чтобы все 3 точки были линейно-независимы, кроме того, мы не можем гарантировать, что координаты точек корректны из-за погрешности компьютерного зрения. Чтобы повысить точность и не перебирать большое количество комбинаций можно использовать альтернативный подход к вычислению матрицы перехода, использующий все доступные точки.
В нашем случае оба базиса ортогональны, а количество точек больше размерности пространства и всегда одинаково на выходе, поэтому возможно использовать алгоритм Кабша-Умеямы.
##### Постановка задачи
Пусть $P$ и $Q$ - два множества по $N$ точек пространства $\mathbb R^n$($N\ge n$). Необходимо найти такой переход из $Q$ в $P$, что среднеквадратичное отклонение между ними минимально
##### Алгоритм
В дальнейшем $P$ и $Q$ это такие матрицы размера $N\times n$, что в строках записаны координаты точек:
$$\begin{pmatrix}x_1&y_1&z_1\\x_2&y_2&z_2\\\vdots&\vdots&\vdots\\x_N&y_N&z_N\end{pmatrix}$$
Первым шагом классическом алгоритме идёт центрирование наборов данных, но так как в нашем случае они имеют общую точку отсчёта(точка между бёдрами), это не является необходимым.
Вторым этапом является вычисление матрицы ковариаций $H$:
$$H=P^TQ$$
Далее вычисляется сама матрица вращения $R$:
$$R=(H^TH^\frac12)H^{-1}$$
Однако для простоты можно использовать другой способ с использованием сингулярного разложения(SVD):
$$H=U\Sigma V^T$$
Тогда $R$ определяется как
$$R=VU^T$$
Если у получившейся матрицы отрицательный определитель $\det(R)\lt0$, то изменим знак последнего столбца $V$:
$$R=V\begin{pmatrix}1&0&0\\0&1&0\\0&0&-1\end{pmatrix}U^T$$
Полученная матрица $R$ и будет нашей матрицей перехода
## Построение скелета
### Калибровка
1. **Запись калибровочного кадра со всех камер**
2. **Детекция меток**
3. **Расчёт матриц перехода**
4. **Сохранение матрицы**

### Основной алгоритм
1. **Перейти к одному базису:**
$$A_{приведённое}=RA_{изначальное}$$
2. **Вычисление веса точки:**
$$weight=\begin{cases}visibility\cdot presence,&\text{если оба параметра определены}\\visibility,&\text{если определён только $visibility$}\\presence,&\text{в остальных случаях}\end{cases}$$
3. **Вычисление координат:**
$$A_{финальное}=\frac{\sum\limits_{k=1}^nweight_k\cdot A_k}{\sum\limits_{k=1}^nweight_k}$$
### Фильтрация
Для исключения шумов и сглаживания финального скелета во времени можно исопльзовать различные фильтры на этапах получения данных и после построения скелета